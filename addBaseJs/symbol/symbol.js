'use strict';

// Тип данных Symbol

// В ES6 стандарте был введен новый тип данных, символы
// По простому символы нужны, чтобы создавать уникальный идентификаторы, чем они и являются
// Обычно применятся к свойствам объектов

// const obj = {
//     name: 'Test', // Название свойства - это строка, кроме строк, свойствами объектов могут быть и символы, только эти два типа данных
// };

// let id = Symbol('id'); // Синтаксис создания символа только такой
// // let id = Symbol(); // Символы можно создавать и без описания
// obj[id] = 1;

// let id2 = Symbol('id'); // Символы всега уникальные, даже если у них одинаковое описание
// console.log(id == id2); // Вернет false, не равны друг другу

// // console.log(obj['id']); // Вернет undefined, т.к. мы образались к свойству объекта через строку, но здесь тип данных Symbol
// console.log(obj[id]);
// console.log(obj);

// const obj = {
//     name: 'Test', // Название свойства - это строка, кроме строк, свойствами объектов могут быть и символы, только эти два типа данных
//     [Symbol('id')]: 1 // Можно и так
// };

// console.log(obj['id']); // Не можем обратиться как к строке
// console.log(obj[id]); // Не можем обратиться как к переменной
// Это и есть одна из причин введения символов, они позволяют скрытые при обычном доступе свойства, которые еще и не показываются при переборе объекта

// for (let value in obj) console.log(value); // Выведет только name
// Это полезно, если мы хотим скрытое свойство

// let id = Symbol('id');

// const obj = {
//     name: 'Test',
//     [id]: 1,
    // getId: function () {
    //     return this[id];
    // }
// };

// const obj = {
//     name: 'Test',
//     [Symbol('id')]: 1,
// };

// console.log(obj.getId()); // Вот таким образом мы можем вернуть наружу это поле
// console.log(Object.getOwnPropertySymbols(obj)); // Встроенный метод, который вернет массив символов объекта
// console.log(obj[Object.getOwnPropertySymbols(obj)[0]]); // Выведет 1

// Это все позволяет нам быть уверенным в том, что это свойство никогда не будет перезаписано


// const myAwesomeDB = {
//     movies: [],
//     actors: [],
//     // id: 123
//     [Symbol('id')]: 123 // Нельзя поменять
// };

// // Сторонний код

// // myAwesomeDB.id = '3232';
// // console.log(myAwesomeDB.id); // Идентификатор поменяется

// console.log(myAwesomeDB);

// https://tc39.es/ecma262/#sec-well-known-symbols
// Документация https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol


// Глобальный реестр символов
// При таком синтаксисе, как у нас сейчас, мы каждый раз будем создавать свой уникальный символ с одинаковыми описаниями, что в принципе правильное поведение
// Но иногда нам необходимо, чтобы символы с одинаковыми именами с их описаниями были одной сущностью
// По простому, мы хотим, чтобы одно описание символа строго соответствовало одному конкретному символу, можно сказать насильно лишить их уникальности
// И можно сделать, если использовать глобальный реестр символов

const myAwesomeDB = {
    movies: [],
    actors: [],
    // id: 123
    [Symbol.for('id')]: 123 // Синтаксис глобального реестра символов
};

console.log(myAwesomeDB[Symbol.for('id')]); // Выведет 123 // Теперь у нас сформировался глобальный реестр символов
// Теперь оно не будет уникальным
